# 2.词法作用域
#### 作用域的一种工作模型，词法作用域就是定义在词法阶段的作用域
### 2.1词法阶段
* 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫做“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符），不会影响外部的变量值。
* 抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。
~~~ JavaScript
function foo(a) {
    var b = a * 2;
    function bar(c) {
      console.log( a, b, c );
    }
    bar( b * 3 );
}
foo( 2 ); // 2, 4, 12
~~~
* 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。
window.a 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。
* 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。
* 词法作用域查找只会查找一级标识符，如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。
### 2.2欺骗词法
##### 修改词法作用域。欺骗词法作用域会导致性能下降。
#### eval(string) 
string中含有要计算的 JavaScript 表达式或要执行的语句。
修改已经存在的词法作用域（在运行时）。
~~~ JavaScript
function foo(str,a){
    eval(str); //欺骗
    console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
}
~~~
eval(..) 调用中的 "var b = 3;" 这段代码会被当作本来就在那里一样来处理。这段代码在foo()内部创建了一个变量b，遮蔽了全局作用域中的b。
在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。
#### with
with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。
本质通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。
~~~ JavaScript
var obj = {
    a: 1,
    b: 2,
    c: 3
};
//赋值快捷方式
with(obj){
    a=3;
    b=4;
    c=5;
}
~~~
~~~ JavaScript
function foo(obj){
    with(obj){
        a=2;
    }
}
var o1={
    a:3
};
var o2{
    b:3
};
foo(o1);
console.log(o1.a); //2

foo(o2); //当执行到a=2时，进行LSH查找，于是在全局作用域中创建了a变量
console.log(o2.a);//undefined 由于o2原本没有变量a

console.log(a); //2 
~~~
这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。
