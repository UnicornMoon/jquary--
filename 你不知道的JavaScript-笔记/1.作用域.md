# 1.作用域

##### 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。

### 1.1编译原理
##### 分词/词法分析
这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。
##### 解析/语法分析：
这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法
结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。
##### 代码生成
将 AST 转换为可执行代码的过程称被称为代码生成。简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。


注：
* 以上是传统编译过程，JavaScript引擎要复杂得多，例如在语法分析和代码生成阶段有特点步骤来对运行性能进行优化，包括对冗余元素进行优化等。
* 与传统编语言不同，它不是提前编译
* JavaScript的编译过程不是发生在构建之前，大部分情况下编译发生在执行前的几微秒（甚至更短）

### 1.2理解作用域
##### 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
* 引擎
从头到尾负责整个 JavaScript 程序的编译及执行过程。
* 编译器
引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。
* 作用域
引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声
明会被分解成两个独立的步骤：
1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
2. 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。
##### 关于查询，分为左查询（LSH），右查询（RSH）；可简单理解赋值操作为执行LSH，取值／引用操作为RSH。

 ```javascript
 var num=10;//左查询
 fun();
 function fun(){
     console.log(num);//右查询 undefined
     var num=20;
 }
 ```
编译器在遇到var a的时候，会询问作用域是否已经有一个该名称的变量存在于同一个作用域，如果有，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。

由于fun()方法里面定义了一个num变量，编译器遇到var num的时候，在当前作用域中声明了一个新的变量num，由于在输出num的时候，变量num还没被赋值，因此输出了undefined。
*  RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。
*  LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会隐式地创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。
### 1.3作用域嵌套
在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。
### 1.4异常
如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError异常。值得注意的是，ReferenceError 是非常重要的异常类型。
ES5的严格模式禁止自动或隐式地创建全局变量。在严格模式中LSH查询失败时，并不会创建并返回一个全局变量，引擎会抛出同RSH查询失败时类似的ReferenceError异常。
