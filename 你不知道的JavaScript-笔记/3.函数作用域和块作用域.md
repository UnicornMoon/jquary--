# 3.函数作用域和块作用域
### 3.1函数中的作用域
属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）
### 3.2隐藏内部实现
在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。
如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。但这样会破坏前面提到的最小特权原则，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。
~~~ JavaScript
function foo(){
    function bar(a){
        i=3; //修改了for循环中的i
        console.log(a+i);
    }
    for(var i=0;i<10;i++){//i被覆盖了
        bar(i*2);  //无限循环
    }
}
foo();
~~~
解决方式：
* bar(..) 内部的赋值操作需要声明一个本地变量来使用，采用任何名字都可以，var i = 3;就可以满足这个需求（同时会为 i 声明一个前面提到过的“遮蔽变量”）。
* 另外一种方法是采用一个完全不同的标识符名称，比如 var j =3;。但是软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是唯一的最佳选择。
### 3.3函数作用域
##### 函数表达式
函数表达式与其他表达式一样，需要先赋值再使用。函数声明可以出现在调用之后。
~~~JavaScript
let functionName=function(a){
    //函数体
}
~~~
如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行。
~~~JavaScript
var a=2;
(function foo(){//自动运行
    var a=3;
    console.log(a);//3
})();
console.log(a);//2
~~~
* foo 被绑定在函数表达式自身的函数中而不是所在作用域中。
* (function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。
##### 匿名和具名
函数表达式可以是匿名的，而函数声明则不可以省略函数名

##### 立即执行函数表达式
~~~JavaScript
var a=2;
(function foo(){//自动运行
    var a=3;
    console.log(a);//3
})();//还可以把调用的()放在里面
console.log(a);//2
~~~
### 3.4块级作用域
##### 在块中隐藏信息 
块级作用域由最近的一对{}界定，if块、while块、function块，甚至单独的块也是let变量声明的作用域。
* var声明变量时，写在哪里都一样，最终都会属于外部作用域
* with是块级作用域的一个例子，用with从对象创建出的作用域仅在with声明而非外部作用域中有效
## let
let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说，let为其声明的变量隐式地了所在的块作用域。
* 在同一作用域不能声明两次
* 使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”。


##### 1.垃圾回收
* 确定变量不会再使用，就释放它的内存。但某块内存是否还有用，属于“不可判定问题”(例：函数中的局部变量)。
* 用{}为变量显式声明块作用域，可帮助引擎更清楚分辨变量是否还有必要保存
~~~JavaScript
function process(data) {
  // 在这里做点有趣的事情
}
// 在这个块中定义的内容可以销毁了！
{
   let someReallyBigData = { .. };
   process( someReallyBigData );
}
var btn = document.getElementById( "my_button" );
btn.addEventListener( "click", function click(evt){
  console.log("button clicked");
}, /*capturingPhase=*/false );
~~~
##### 2.防止内层变量覆盖外层

~~~javascript
function foo(){
    let n=5;
    if(true){
        let n=10;
    }
    console.log(n); //5
}
//说明外层代码块不受内存代码块影响
~~~
##### 3.循环
for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。
~~~javascript
{
    let j;
    for(j=0;j<10;j++){
        let i=j;//每个迭代重新绑定！
        console.log(i);
    }
}
~~~
let 声明附属于一个新的作用域而不是当前的函数作用域（也不属于全局作用域）
## const
同样可以用来创建块作用域变量，但其值是固定的（常量），声明时必须初始化为某个值，后面修改会引起错误。
const除了要遵循以上规则，其他方面与let声明一样。
* const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
* 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
~~~JavaScript
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
~~~
上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

如果想让整个对象都不能修改，可以使用object.freeze(),给属性赋值时会静默失败，严格模式会报错。


注：var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。
~~~JavaScript
var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
~~~